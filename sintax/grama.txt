PROGRAMA → SEÇÃOFUNÇÕES PRINCIPAL
SEÇÃOFUNÇÕES → LISTAFUNÇÕES | ε
LISTAFUNÇÕES → DECFUNÇÃO | LISTAFUNÇÕES DECFUNÇÃO
DECFUNÇÃO → TIPORETORNO id ( PARÂMETROS ) BLOCO
TIPORETORNO → TIPO | void
TIPO → TIPOBASE DIMENSÃO
TIPOBASE → char | float | int | boolean
DIMENSÃO → DIMENSÃO [ num_int ] | ε
PARÂMETROS → LISTAPARÂMETROS | ε
LISTAPARÂMETROS → TIPO id | LISTAPARÂMETROS , TIPO id
PRINCIPAL → main ( ) BLOCO
BLOCO → { SEÇÃOVARIAVEIS SEÇÃOCOMANDOS }
SEÇÃOVARIAVEIS → LISTAVARIAVEIS | ε
LISTAVARIAVEIS → TIPO LISTAID ; | LISTAVARIAVEIS TIPO LISTAID ;
LISTAID → identificador | LISTAID , identificador
SEÇÃOCOMANDOS → LISTACOMANDOS | ε
LISTACOMANDOS → COMANDO | LISTACOMANDOS COMANDO
COMANDO → LEITURA | ESCRITA | ATRIBUIÇÃO | FUNÇÃO | SELEÇÃO | ENQUANTO |
RETORNO
LEITURA → scanf ( LISTATERMOLEITURA ) ;
LISTATERMOLEITURA → TERMOLEITURA| LISTATERMOLEITURA , TERMOLEITURA
TERMOLEITURA → id DIMENSAO2
DIMENSAO2 → DIMENSAO2 [ EXPR_ADITIVA ] | ε
ESCRITA → println ( LISTATERMOESCRITA ) ;
LISTATERMOESCRITA → TERMOESCRITA | LISTATERMOESCRITA , TERMOESCRITA
TERMOESCRITA → id DIMENSAO2 | CONSTANTE | texto
SELEÇÃO → if ( EXPRESSÃO ) BLOCO SENÃO
SENÃO → else BLOCO | ε
ENQUANTO → while ( EXPRESSÃO ) BLOCO
ATRIBUIÇÃO → id = COMPLEMENTO ;
COMPLEMENTO → EXPRESSÃO | FUNÇÃO
FUNÇÃO → func id ( ARGUMENTOS )
ARGUMENTOS → LISTAARGUMENTOS | ε

LISTAARGUMENTOS → EXPRESSÃO | LISTAARGUMENTOS , EXPRESSÃO
RETORNO → return EXPRESSÃO ;
EXPRESSÃO → EXPR_OU
EXPR_OU → EXPR_E | EXPR_OU || EXPR_E
EXPR_E → EXPR_RELACIONAL | EXPR_E && EXPR_RELACIONAL
EXPR_RELACIONAL → EXPR_ADITIVA | EXPR_ADITIVA opRelacional EXPR_ADITIVA
EXPR_ADITIVA → EXPR_MULTIPLICATIVA |

EXPR_ADITIVA OP_ADITIVO EXPR_MULTIPLICATIVA

OP_ADITIVO → + | -
EXPR_MULTIPLICATIVA → FATOR |

EXPR_MULTIPLICATIVA OP_MULTIPLICATIVO FATOR

OP_MULTIPLICATIVO → * | / | %
FATOR → SINAL identificador DIMENSAO2 | SINAL CONSTANTE | texto | ! FATOR
| ( EXPRESSÃO )
CONSTANTE → num_int | num_dec
SINAL → + | - | ε

Vamos separar os não terminais dos terminais para a gramática fornecida:

### Não Terminais
Os não terminais são os símbolos que podem ser expandidos em outras produções. Na gramática fornecida, os não terminais são:

- PROGRAMA
- SEÇÃOFUNÇÕES
- LISTAFUNÇÕES
- DECFUNÇÃO
- TIPORETORNO
- TIPO
- TIPOBASE
- DIMENSÃO
- PARÂMETROS
- LISTAPARÂMETROS
- PRINCIPAL
- BLOCO
- SEÇÃOVARIAVEIS
- LISTAVARIAVEIS
- LISTAID
- SEÇÃOCOMANDOS
- LISTACOMANDOS
- COMANDO
- LEITURA
- LISTATERMOLEITURA
- TERMOLEITURA
- DIMENSAO2
- ESCRITA
- LISTATERMOESCRITA
- TERMOESCRITA
- SELEÇÃO
- SENÃO
- ENQUANTO
- ATRIBUIÇÃO
- COMPLEMENTO
- FUNÇÃO
- ARGUMENTOS
- LISTAARGUMENTOS
- RETORNO
- EXPRESSÃO
- EXPR_OU
- EXPR_E
- EXPR_RELACIONAL
- EXPR_ADITIVA
- OP_ADITIVO
- EXPR_MULTIPLICATIVA
- OP_MULTIPLICATIVO
- FATOR
- CONSTANTE
- SINAL


### Terminais
Os terminais são os símbolos que não podem ser expandidos em outras produções. Eles representam os tokens finais que aparecem na linguagem. Na gramática fornecida, os terminais são:

- `id`
- `num_int`
- `num_dec`
- `char`
- `float`
- `int`
- `boolean`
- `void`
- `main`
- `{`
- `}`
- `(`
- `)`
- `[`
- `]`
- `;`
- `,`
- `=`
- `+`
- `-`
- `*`
- `/`
- `%`
- `!`
- `return`
- `func`
- `scanf`
- `println`
- `if`
- `else`
- `while`
- `||`
- `&&`
- `opRelacional` (um terminal genérico para operadores relacionais)
- `CONSTANTE`
- `texto`
- `$` (símbolo de fim de entrada)
- `ε` (representa a produção vazia)

Com estas listas, você pode distinguir claramente entre os símbolos terminais e não terminais na gramática.

# A analise será feita de forma as descendentes pois são na teoria mais simples de se implementar doq os ascendentes

# Para fazermos um analisador sintático é necessário utilizar regras de produção

# Devemos separar em grupos como Cabeça, Final, First e Follow
# Cabeça é o primeiro caracter a direita da linha de produção sendo terminal ou não terminal
# Final é o último caracter a direta da linha de produção sendo terminal ou não terminal
# First é o primeiro caracter a direta da linha de produção sendo terminal caso seja vazio é feito uma união com o first do próximo não teminal

# sendo A um não terminal o Follow é o conjunto de terminais que aparecem a frente imediatamente a frente do mesmo, 
# caso haja (vazio) é folloW de A é toda a linha de produção que A está inserido

"""
Exemplo 


A -> BC
B -> a|b|(vazio)
C -> c

obs: cada | apresenta um para o first

firstA = firstB (união) firstC = a,b,c,(vazio)
followA = firstC = c


Exemplo de derivação:

Gramatica:
S -> AG (1)
A -> aDF (2)
F -> f (3) |fR (5) |(vazio) (6)
G -> g (7)

Derivação:
S -> (iniciou derivação)
AG -> (Aplicou regra 1)
aDFG -> (aplicou regra 2)
aD G -> (aplicou a regra 6)

onde follow de D é igua follow de A

Construtor função:

sendo isto F = função, T = Tipo, I = indentificador, .. = Qlq código dentro
F -> T I ( T ) { .. }

"""