Programa -> DeclaraçãoLista

DeclaraçãoLista -> Declaração
                 | Declaração DeclaraçãoLista

Declaração -> DeclaraçãoVariável
             | DeclaraçãoFunção
             | DeclaraçãoEstrutura

DeclaraçãoVariável -> Tipo Identificador ';'
                    | Tipo Identificador '[' Número ']' ';'

DeclaraçãoFunção -> Tipo Identificador '(' ListaParâmetros ')' DeclaraçãoComposta

DeclaraçãoComposta -> '{' DeclaraçãoLista '}'

Tipo -> 'int' | 'float' | 'char' | 'void'

ListaParâmetros -> ListaVazia
                  | ListaParâmetros
                  | Tipo Identificador
                  | Tipo Identificador ',' ListaParâmetros

DeclaraçãoEstrutura -> 'struct' Identificador '{' DeclaraçãoLista '}' ';'

Expressão -> ExpressãoAtribuição
           | Expressão ',' ExpressãoAtribuição

ExpressãoAtribuição -> Identificador '=' Expressão
                      | ExpressãoCondicional

ExpressãoCondicional -> ExpressãoLogica '?' Expressão ':' Expressão

ExpressãoLogica -> ExpressãoLogica '||' ExpressãoLogica
                 | ExpressãoLogica '&&' ExpressãoLogica
                 | ExpressãoRelacional

ExpressãoRelacional -> ExpressãoAditiva '>' ExpressãoAditiva
                      | ExpressãoAditiva '<' ExpressãoAditiva
                      | ExpressãoAditiva '>=' ExpressãoAditiva
                      | ExpressãoAditiva '<=' ExpressãoAditiva
                      | ExpressãoAditiva '==' ExpressãoAditiva
                      | ExpressãoAditiva '!=' ExpressãoAditiva

ExpressãoAditiva -> ExpressãoAditiva '+' Termo
                   | ExpressãoAditiva '-' Termo
                   | Termo

Termo -> Termo '*' Fator
        | Termo '/' Fator
        | Fator

Fator -> '(' Expressão ')'
        | Número
        | Identificador

Identificador -> [a-zA-Z_][a-zA-Z0-9_]*
Número -> [0-9]+

ListaVazia -> ε







# A analise será feita de forma as descendentes pois são na teoria mais simples de se implementar doq os ascendentes

# Para fazermos um analisador sintático é necessário utilizar regras de produção

# Devemos separar em grupos como Cabeça, Final, First e Follow
# Cabeça é o primeiro caracter a direita da linha de produção sendo terminal ou não terminal
# Final é o último caracter a direta da linha de produção sendo terminal ou não terminal
# First é o primeiro caracter a direta da linha de produção sendo terminal caso seja vazio é feito uma união com o first do próximo não teminal

# sendo A um não terminal o Follow é o conjunto de terminais que aparecem a frente imediatamente a frente do mesmo, 
# caso haja (vazio) é folloW de A é toda a linha de produção que A está inserido

"""
Exemplo 


A -> BC
B -> a|b|(vazio)
C -> c

obs: cada | apresenta um para o first

firstA = firstB (união) firstC = a,b,c,(vazio)
followA = firstC = c


Exemplo de derivação:

Gramatica:
S -> AG (1)
A -> aDF (2)
F -> f (3) |fR (5) |(vazio) (6)
G -> g (7)

Derivação:
S -> (iniciou derivação)
AG -> (Aplicou regra 1)
aDFG -> (aplicou regra 2)
aD G -> (aplicou a regra 6)

onde follow de D é igua follow de A

Construtor função:

sendo isto F = função, T = Tipo, I = indentificador, .. = Qlq código dentro
F -> T I ( T ) { .. }

"""

programa  -> lista_declaracoes

lista_declaracoes  -> declaracao | lista_declaracoes declaracao

declaracao  -> declaracao_variavel | declaracao_funcao

declaracao_variavel  -> tipo identificador ';'

tipo  -> 'int' | 'float' | 'char'

identificador  -> ID

declaracao_funcao  -> tipo identificador '(' parametros ')' '{' lista_instrucoes '}'

parametros  -> lista_parametros | vazio

lista_parametros  -> parametro | lista_parametros ',' parametro

parametro  -> tipo identificador

lista_instrucoes  -> instrucao | lista_instrucoes instrucao

instrucao  -> declaracao_variavel | atribuicao | instrucao_condicional | instrucao_loop | retorno | chamada_funcao

atribuicao  -> identificador '=' expressao ';'

expressao  -> termo | expressao '+' termo | expressao '-' termo

termo  -> fator | termo '*' fator | termo '/' fator

fator  -> identificador | numero | '(' expressao ')'

numero  -> NUM

instrucao_condicional  -> 'if' '(' expressao ')' '{' lista_instrucoes '}' ('else' '{' lista_instrucoes '}')?

instrucao_loop  -> 'while' '(' expressao ')' '{' lista_instrucoes '}'

retorno  -> 'return' expressao ';'

chamada_funcao  -> identificador '(' lista_argumentos ')'

lista_argumentos  -> lista_expressoes | vazio

lista_expressoes  -> expressao | lista_expressoes ',' expressao
